=====================================================================================
# :scroll: GUIA DE PROYECTOS REALIZADOS EN LA ESCUELA 42 NETWORK (B√âLGICA)
=====================================================================================
- [Normas generales](#normas-generales)
- [Proyectos realizados](#proyectos)
  - [Libft](#libft)
  - [Get next line](#get-next-line)
  - [NetWhat](#netwhat)
  - [Ft_printf](#ft-printf)
  - [Ft_server](#ft-server)
- [Tabla de proyectos](#tabla-de-proyectos)

=====================================================================================
# <h1 align="center">NORMAS GENERALES</h1>
=====================================================================================
## IMPORTANTE ‚ùó

Cada uno de los proyectos contiene **PDFs** tanto en **espa√±ol** como en **ingl√©s** de las restricciones e instrucciones a seguir para resolver cada uno de los proyectos, si se desea una mayor comprensi√≥n de √©stos, dir√≠jase a sus respectivos PDFs.

<br>

## üìî NORMALIZACI√ìN
Para llegar a ser un buen desarrollador no s√≥lo debemos saber escribir **buen c√≥digo**, sino que tambi√©n debemos aprender a que nuestro c√≥digo sea **lo m√°s legible** posible para otros programadores. Es por ello que en 42, usamos nuestra propia `NORMA (norm)` a la hora de empezar un nuevo proyecto. Puedes echarle un vistazo aqui: <a href="https://github.com/suker/42-Cadet/blob/master/en.normv3.pdf">NORMA</a>


<br>

## üìå CRITERIOS DE CALIFICACI√ìN Y EVALUACI√ìN

A la hora de evaluar un proyecto en 42 no aceptamos un proyecto `casi bien` o un `99.99% completado`, sino que buscamos que nuestros estudiantes realicen cada uno de los proyectos cumpliendo con **TODOS** los requisitos previos y buscando siempre el :100:%.

**Los criterios son otorgados al evaluador cuando un proyecto est√° siendo evaluado.** El evaluador deber√° por tanto ir leyendo y cumpliendo (testeando) cada uno de ellos.
Adem√°s, el evaluador podr√° realizar preguntas sobre c√≥mo se ha realizado el proyecto y su estructura (_para saber si ha sido un copy & paste_).

**Para que un proyecto sea calificado como v√°lido se deben cumplir una serie de pasos:**
- Todo proyecto debe **cumplir todas y cada una de las instrucciones** que se detallan tanto en el **PDF del proyecto** c√≥mo en la **NORMA**.
- El proyecto debe ser **validado por 3 estudiantes**.
- El proyecto debe ser **validado por Moulinette** (programa que evalua ciertos proyectos).


=====================================================================================
# <h1 align="center">PROYECTOS</h1>
=====================================================================================

# LIBFT
## üåü INTRODUCCI√ìN

La programaci√≥n en C puede ser muy tediosa cuando no se tiene acceso a las funciones est√°ndar muy √∫tiles. Este proyecto, te da la oportunidad de reescribir aquellas funciones para entenderlas y aprender a usarlas. La librer√≠a te ayudar√° para tus futuros proyectos en C.
A trav√©s de este proyecto, te damos la oportunidad de extender tu lista de funciones a tu manera! T√≥mate tu tiempo para expandirla a lo largo del curso.


<br>

## üéØ OBJETIVO

**Generar una librer√≠a est√°tica `libft.a` mediante el uso de un `Makefile` que contenga las funciones a realizar.**

<br>

## üêæ DESARROLLO
1. Recrear las funciones de **la parte obligatoria** (*parte 1 y parte 2*).
2. Realizar la parte de bonus **(opcional si se desea una puntuaci√≥n extra)**.
3. Crear un **Makefile** para generar nuestra librer√≠a: `libft.a`.
4. Testear nuestro c√≥digo con testers personalizados propios o de terceros.

<br>

### üö¢ Parte Obligatoria 1

Las funciones de la parte 1 son algunas de las funciones de la biblioteca est√°ndar en C `libc`. √âstas funciones deber√°n ser realizadas conforme su manual `man` indica. Es decir, que para saber sus instrucciones debemos leer el manual ya sea en **Internet** o en el **terminal** del SO que utilicemos (*en nuestro caso MacOS*).

<details>
  
  <summary>üî∂ Por ejemplo</summary>
  <b> 'man strlen' nos detalla el prototipo, descripci√≥n y valor a retornar de la funci√≥n.</b><br>
  
  
  
  ![image](https://user-images.githubusercontent.com/1337928/112439792-d6c07c00-8d49-11eb-9fb3-27f739dbab33.png)

</details>

<br>

### üöÄ Parte obligatoria 2

Las funciones de esta parte se encuentran detalladas en el **pdf**.

<details>
  
  <summary>üî∂ Por ejemplo</summary>
  
  ![image](https://user-images.githubusercontent.com/1337928/112442192-e214a700-8d4b-11eb-9167-7a16a65fa8aa.png)
  <br>
  
  En la funci√≥n **ft_split**, se nos pide que al **recibir una cadena de caracteres `char * s` y un caracter como separador `char c` como argumentos**, debamos     devolver o **retornar** un array de strings (*pointer of a pointer* or *2 dimensional array*) alojando memoria con **malloc**. En caso de error: retornar un     puntero NULO `NULL`.

</details>




<br>

### üíé Parte Bonus

Esta parte es considerada como **bonus**, y por tanto **solo ser√° evaluada** si hemos completado **correctamente la parte obligatoria.**
Normalmente los bonus requieren un **grado de complejidad mayor** con respecto a la anterior parte.

Es decisi√≥n del programador realizar esta parte total o parcialmente ya que **los puntos extras** depender√° de los **criterios establecidos para su evaluaci√≥n.**

En este bonus se nos pide realizar una serie de funciones orientadas a la estructura de datos **listas enlazadas**, y para ello debemos hacer uso de las **estructuras** `struct` dentro de nuesto archivo **header** `.h`.
<details>
  
  <summary>Clikea para ver el HEADER!</summary>
  
  ![image](https://user-images.githubusercontent.com/1337928/112445068-0756e480-8d4f-11eb-8c4c-937ffd9427b3.png)
  
</details>

<details>
  
  <summary>üî∂ Por ejemplo</summary>

![image](https://user-images.githubusercontent.com/1337928/112445378-5866d880-8d4f-11eb-8581-54e7b126f247.png)

La funci√≥n **ft_lstmap** recibir√° como argumentos el **puntero a la lista**, **el puntero a la funci√≥n** `f` y **un puntero a la funci√≥n** `del`.
Lo que deberemos hacer es **crear una nueva lista** e ir guardando en ella el resultado de iterar cada elemento de la lista `lst` al aplicarle el contenido de la funcion `f`. En caso de error a la hora de alojar memoria con `malloc`, debemos **limpiar el contenido de nuestra nueva lista** y retornar `NULL`.

</details>


=====================================================================================

# GET NEXT LINE

## üåü INTRODUCCI√ìN

Este proyecto tiene como objetivo entender c√≥mo se abren, leen y cierran los archivos en un SO, y c√≥mo se interpretran por medio de un lenguaje de programaci√≥n para su posterior an√°lisis.
Esta tarea es crucial entender para un futuro programador ya que gran parte de nuestro tiempo se basa en manipular archivos para la gesti√≥n y persistencia de datos.

<br>

## üéØ OBJETIVO

Escribir una funci√≥n que devuelva una l√≠nea dentro de un archivo de texto que termine con un salto de l√≠nea `char = '\n'`, le√≠da desde un descriptor de archivos.

‚ÑπÔ∏è Para m√°s informaci√≥n: [PDF](https://github.com/suker/42-Cadet/blob/master/42-libft/es.subject.pdf)

<br>

## üêæ DESARROLLO

Para desarrollar este proyecto, debemos entender una serie de conceptos:

1. **¬øC√≥mo funciona `read()`, `open()`, `close()`?**
2. **¬øQu√© son y c√≥mo se utilizan los descriptores de archivo?**
3. **¬øQu√© son las variables est√°ticas `static` y cu√°l es su uso en el proyecto?** 

<br>

### 1. ¬øC√≥mo funciona `read()`, `open()`, `close()`?

Para un mayor entendimiento, referirse a sus respectivos manuales en el terminal: üî∂ e.g: `man 2 open` | `man 2 read` | `man 2 close`

O consultar en estos enlaces:
üëâ [read](https://linux.die.net/man/3/read)
üëâ [open](https://linux.die.net/man/3/open)
üëâ [close](https://linux.die.net/man/3/close)


<br><h4 align="center">Pasos b√°sicos para operar con un archivo.</h4>

1. Debemos de **abrir el archivo y sus permisos y asignarle el fd correspondiente**. üî∂ E.g `int fd = open('/usr/suker/file.txt', O_RDWR);`.
  - Si `fd = -1`, el archivo **no existe el archivo o no se ha podido abrir correctamente**.
  - Si `fd > 2`, el archivo ha sido **abierto correctamente**.
2. Procedemos a leer el archivo con `int num_bytes = read(fd, buf, nbyte);`.
  - si `num_bytes < 0`, el archivo **no tiene permisos de lectura**. 
  - si `num_bytes > 0`, el archivo **ha le√≠do** `num_bytes` de **bytes**.
3. Tras haber le√≠do `num_bytes` de caracteres y almacenado temporalmente en `buf` realizamos la **tarea necesaria con los datos le√≠dos** y procedemos a cerrar nuestro archivo con `close(fd)`.

<br>

### 2. ¬øQu√© son y c√≥mo se utilizan los descriptores de archivo?

En **Unix** y **sistemas operativos** de computadora relacionados , **un descriptor de archivo** `FD` es un indicador abstracto (*identificador*) que se usa para **acceder a un archivo u otro recurso de entrada / salida**, como una tuber√≠a o un conector de red.

Los descriptores de archivo forman parte de la interfaz de programaci√≥n de la aplicaci√≥n POSIX .

**Un descriptor de archivo es un n√∫mero entero no negativo**, generalmente representado en el lenguaje de programaci√≥n C como el tipo `int` (*los valores negativos se reservan para indicar "sin valor" o una condici√≥n de error*).
|Valor entero|Nombre|constante simb√≥lica `<unistd.h>` | flujo de archivo Descriptor de archivo `<stdio.h>` |
|------------|------------|------------|------------|
| 0 | Entrada est√°ndar | STDIN_FILENO | stdin |
| 1 | Salida est√°ndar | STDOUT_FILENO | stdout |
| 2 | Error est√°ndar | STDERR_FILENO | stderr |
| > 2 | Indica el valor entero que le pertenece al archivo que est√° abierto | ‚ûñ | ‚ûñ |

üëâ [Fuente](https://es.qaz.wiki/wiki/File_descriptor) üëà

Los descriptores de archivo podemos utilizarlos y obtenerlos en funciones b√°sicas como:
- **int open(const char *path, int oflag, ...):** `path` puntero a la ruta d√≥nde se encuentra el archivo, `oflags` c√≥mo queremos abrir nuesto archivo. e.g: **solo lectura: **`O_RDONLY`, ** s√≥lo escritura**, `O_WRONLY`, **ambos:** `O_RDWR`
  - Librerias necesarias: `<fcntl.h>`.

- **ssize_t read(int fd, void *buf, size_t nbyte):** `fd` file descriptor, `buf` puntero de caracteres que almanacena los carateres le√≠dos, `nbyte` numero de bytes que se pretende leer por cada `read()`.
  - Librerias necesarias: `<sys/types.h>`, `<sys/uio.h>`, `<unistd.h>`.

- **int close(int fd):** `fd` file descriptor. Retorna `-1` si el archivo no se ha cerrado correctamente.
  - Librerias necesarias: `<fcntl.h>`.


<br>

### 3. ¬øQu√© son las variables est√°ticas `static` y cu√°l es su uso en el proyecto?

Al tener restricciones en el uso de **variables globales** dentro de nuestro proyecto, debemos aprender lo que son las **variables est√°ticas** y para qu√© nos sirven.
En resumen, una variable est√°tica nos permite la **persistencia de informaci√≥n** aunque la funci√≥n que la contenga se haya **terminado de ejectutar.** (recordemos que **el √°mbito de una variable** nos limita desde d√≥nde se puede acceder y manipular su contenido).

`Get_next_line()` (*abreveviado:*`gnl()`) es una funci√≥n que nos retornar√° una l√≠nea por cada vez que llamemos a la funci√≥n, pero debido a las instrucciones de este proyecto, el n√∫mero de bytes `BUFFER_SIZE` que leamos por cada vez que llamemos a `gnl()` ser√° determinado por el evaluador. Es decir que `BUFFER_SIZE` podr√° ser un n√∫mero negativo hasta un n√∫mero inmesanmente grande ‚ôæÔ∏è. 

Por lo tanto, si pretendemos leer un archivo con `1000 l√≠neas de texto` y nuestro `BUFFER_SIZE > Numero de bytes del archivo`, la lectura del archivo ser√° en una sola llamada de `read()`, por lo que debemos hacer que nuestras l√≠neas de texto **persistan en una sola variable** tras m√∫ltiples llamadas de `gnl()`.

<p align="center">‚ùó‚ùó‚ùó PARA MAYOR ENTENDIMIENTO, CONSULTAR LOS COMENTARIOS DEL C√ìDIGO ‚ùó‚ùó‚ùó </p>

=====================================================================================

# NETWHAT
## üåü INTRODUCCI√ìN

La administraci√≥n y sistemas de redes es una herramienta importante a la mano del futuro programador, conocer c√≥mo se **envian y recibe la informaci√≥n** a trav√©s de internet de manera segura es crucial para ser capaces de gestionarla correctamente.

Netwhat es un cuestionario. Este proyecto sirve para evaluar y ayudar a adquirir conocimientos sobre redes. Desde ahora puede empezar a leer **documentaci√≥n sobre redes en Internet.**

<br>

## üéØ OBJETIVO

Superar el cuestionario que se encuentra en [netwhat](https://www.netwhat.42.fr). Este cuestionario consta de 20 preguntas tanto te√≥ricas como pr√°cticas.
Adem√°s para agregarle un mayor grado de dificultad, cada pregunta consta de 30 segundos para su respuesta. Buena Suerte ‚ùï

‚ÑπÔ∏è Para m√°s informaci√≥n: [PDF](https://github.com/suker/42-Cadet/blob/master/42-netwhat/en.subject.pdf)

<br>

## üêæ DESARROLLO

El desarrollo de este proyecto no se basa en c√≥digo, sino en teor√≠a y pr√°ctica sobre redes. Abajo se detallan cada uno de los apartados a tomar en cuenta.

- [¬øQu√© es una direcci√≥n IP?](https://www.es.paessler.com/it-explained/ip-address)
- [¬øQu√© es una m√°scara de red?](https://es.wikipedia.org/wiki/M%C3%A1scara_de_red)
- [¬øQu√© es la subred de una IP con m√°scara de red?](https://es.wikipedia.org/wiki/Subred#:~:text=En%20redes%20de%20computadoras%2C%20una,la%20red%20m%C3%A1s%20manejable%2C%20administrativamente.)
- [¬øCu√°l es la direcci√≥n de transmisi√≥n (broadcast) de una subred?](https://www.ionos.es/digitalguide/servidores/know-how/broadcast-ip/)
- [¬øCu√°les son las diferentes formas de representar una direcci√≥n IP con la m√°scara de red?](https://codingornot.com/configuracion-de-redes-i-que-es-la-ip-y-la-mascara-de-subred)
- [¬øCu√°les son las diferencias entre IP p√∫blica y privada?](https://www.testdevelocidad.es/2016/08/04/direccion-ip-publica-privada-diferencias-saber-ip-cambiarla/#:~:text=La%20p%C3%BAblica%20es%20el%20identificador,el%20router%20asigna%20a%20nuestro)
- [¬øQu√© es una clase de IP?](https://citelia.es/blog/tipos-direcciones-ip/)
- [¬øQu√© es TCP (Protocolo de Control de Transmisi√≥n)?](https://developer.mozilla.org/es/docs/Glossary/TCP)
- [¬øWhat is UDP (Protocolo de Datagrama de Usuario)?](https://www.ionos.es/digitalguide/servidores/know-how/udp-user-datagram-protocol/)
- [¬øQu√© son las capas de red?](https://es.wikipedia.org/wiki/Capa_de_red)
- [¬øQu√© es el modelo OSI?](https://es.wikipedia.org/wiki/Modelo_OSI)
- [¬øQu√© es un servidor DHCP y el protocolo DHCP?](https://www.ionos.es/digitalguide/servidores/configuracion/que-es-el-dhcp-y-como-funciona/)
- [¬øQu√© es un servidor DNS y el protocolo DNS?](https://es.wikipedia.org/wiki/Sistema_de_nombres_de_dominio)
- [¬øCu√°les son las reglas para hacer que 2 dispositivos se comuniquen usando direcciones IP?](https://es.wikipedia.org/wiki/Red_de_computadoras)
- [¬øC√≥mo funciona el enrutamiento con IP?](https://ccnadesdecero.com/curso/enrutamiento-ip/)
- [¬øQu√© es una puerta de enlace predeterminada para enrutamiento?](https://obstina-bourgas.org/diferente/que-es-la-puerta-de-enlace-predeterminada/)
- [¬øQu√© es un puerto desde el punto de vista IP y para qu√© sirve cuando se conecta a otro dispositivo?](https://www.le-vpn.com/es/que-es-la-redireccion-de-puertos/)

=====================================================================================

# FT PRINTF
## üåü INTRODUCCI√ìN

Este proyecto te permitir√° descubrir las **funciones vari√°dicas** y su potencial impacto dentro de la programaci√≥n.
La **versatilidad de la funci√≥n printf** en C representa un gran ejercicio de programaci√≥n para nosotros.
La clave para un ft_printf exitoso es un **c√≥digo extensible y bien estructurado.**

<br>

## üéØ OBJETIVO

En este proyecto se pretende recrear la funci√≥n de la libreria est√°ndar `printf`, para su realizaci√≥n deberemos de entender qu√© son las funciones vari√°dicas `variadic functions` y c√≥mo se utilizan a la hora de codificar.

‚ÑπÔ∏è Para m√°s informaci√≥n: [PDF](https://github.com/suker/42-Cadet/blob/master/42-ft_printf/es.subject.pdf)

<br>

## üêæ DESARROLLO

La clave para resolver este proyecto est√° en **estructurar bien las funciones y dividir el trabajo** (*divide y venceras strategy!*).
Antes de entrar en el algoritmo del proyecto, deberemos estar familiarizados con un par de puntos:

1. **¬øQu√© son las funciones vari√°dicas?**
2. **¬øCu√°l es el uso de la funci√≥n printf y c√≥mo maneja sus argumentos?**

### 1. ¬øQu√© son las funciones vari√°dicas?

En resumen, **las funciones vari√°dicas** nos permiten recibir un **n√∫mero variable de argumentos**.
Esto nos da una gran abanico de posibilidades cu√°ndo trabajamos con funciones que requieren **m√∫ltiples par√°metros** de entrada o una gran variedad de tipos de datos.

‚ÑπÔ∏è Para m√°s informaci√≥n: [Funciones vari√°dicas](https://trucosinformaticos.wordpress.com/2018/11/25/funciones-variadicas/)

### 2. ¬øCu√°l es el uso de la funci√≥n printf y c√≥mo maneja sus argumentos?



<details>
  <summary>Prototipo y campos requeridos de PRINTF</summary>
   <b>Prototipo: int printf(const char * format, ...);</b>
  
  ![image](https://user-images.githubusercontent.com/1337928/112623049-26777400-8e2c-11eb-90ce-ddfb273db9e0.png)

</details>

La funci√≥n printf printea en la salida √©standar el valor de sus argumentos, despu√©s del primero, bajo el control del formato `format`. El formato es una cadena de caracteres que contiene tres tipos de objetos: **caracteres sin formato**, que simplemente se copian en la salida √©standar, **secuencia de escape de caracteres** que se convierten y se copian en la salida est√°ndar, y especificadores de formato `format specifiers`, cada una de las cu√°les causa la impresi√≥n `printing` del siguiente argumento.

üî∂ Por ejemplo: `total_chars = printf("hola soy %s, y tengo %d a√±os.", "Juan", 26)`.
1. printea en la salida est√°ndar `"hola soy "`.
2. lee el especificador del formato de tipo `char *` '%s' y printea su contenido del siguiente argumento: `"hola soy Juan"`.
3. sigue printeando caracteres sin formato: "hola soy Juan, y tengo ".
4. lee el ultimo especificador del formato de tipo `int` '%d': `"hola soy Juan, y tengo 26"`.
5. finaliza los ultimos caracteres sin formato: `"hola soy Juan, y tengo 26 a√±os."`.
6. Retorna el n√∫mero de caracteres printeados en total: `total_chars: 31`.

‚ÑπÔ∏è Para m√°s informaci√≥n: [Funci√≥n printf](https://docs.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=msvc-160)

<br>

## üí• ALGORITMO:

Cada programador tiene diferente manera de pensar y de razonar a la hora de realizar un proyecto. En base a la experiencia es cu√°ndo adquirimos conocimientos
que nos llevan a desarrollar cada vez mejor. Para m√≠ este proyecto lo he divido en una serie de pasos simples:

1. Crear una lista enlazada de estructuras `struct` las cuales contengan informaci√≥n valiosa para cada *especificador de formato*. En su defecto, si el **formato** no contiene *especificadores*, printear los caracteres sin crear la lista.

2. Por cada estructura, rellenamos sus variables en base a qu√© tipo de argumentos recibimos: üî∂ e.g: tipo `%d int`, `%s char *`, `%p pointer`, `%10.2u unsigned con width y precision`, ect..

3. Comprobamos si cada elemento de nuestra lista contiene alg√∫n fallo en la **syntaxis del especificador de formato**: üî∂ e.g: tipo `%432f.3$$d`.
    - Si **existe un error**, **liberamos la memoria** asignada de nuestra lista de estructuras y **retornamos -1.**
    - Caso contrario, procedemos a printear nuestro contenido. 

4. Recorremos el formato buscando **caractes sin formato**, **caracteres de escape** y **caracteres con formato** hasta llegar al final de la string.
5. Debemos **liberar la memoria asignada de nuestra lista**.
6. Y por √∫ltimo, **retornamos el n√∫mero de caracteres impresos.**

<br><p align="center">‚ùó‚ùó‚ùó PARA MAYOR ENTENDIMIENTO, CONSULTAR LOS COMENTARIOS DEL C√ìDIGO ‚ùó‚ùó‚ùó </p><br><br>

=====================================================================================

# FT SERVER
## üåü INTRODUCCI√ìN

Este tema tiene como objetivo presentar la **administraci√≥n del sistema**. Te har√° consciente de la importancia de utilizar **scripts para automatizar tus tareas.** Para eso, descubrir√°s la tecnolog√≠a `docker` y la usar√°s para instalar un **servidor web completo.** Este servidor ejecutar√° m√∫ltiples servicios: **Wordpress, phpMyAdmin y una base de datos SQL.**

<br>

## üéØ OBJETIVO

Crear y mantener un servidor web `Nginx` utilizando la tecnolog√≠a `Docker` para el despligue de nuestra web. Usaremos los servicios de **Wordpress, phpmyadmin y MariaDB**.

‚ÑπÔ∏è Para m√°s informaci√≥n: [PDF](https://github.com/suker/42-Cadet/blob/master/42-ft_server/es.subject.pdf)

<br>

## üêæ DESARROLLO

La mayor parte de este proyecto se basa en leer la documentaci√≥n de cada uno de los apartados a implementar: `Docker` como gestor de aplicaciones `Nginx` como servidor web, `Wordpress` como gestor de contenido web, `phpmyadmin` como gestor de nuestra base de datos a trav√©s de la web, y por √∫ltimo, `SQL o MariaDB` como nuestra base de datos.

Recursos utilizados:
- [Docker](https://docs.docker.com/get-started/)
- [Nginx](http://nginx.org/en/docs/beginners_guide.html)
- [Wordpress](https://es.wordpress.org/download/) S√≥lo hay que descargar el archivo .tar y descomprimir la carpeta en el directorio necesario ‚ùó
- [phpmyadmin](https://docs.phpmyadmin.net/es/latest/config.html)
- [SQL](https://www.digitalocean.com/community/tutorials/crear-un-nuevo-usuario-y-otorgarle-permisos-en-mysql-es)
- EXTRAS
  - [Redireccionamiento HTTP hacia HTTPS en Nginx](https://linuxize.com/post/redirect-http-to-https-in-nginx/)
  - [Comprensi√≥n de los algoritmos de selecci√≥n de bloques de ubicaci√≥n y servidor Nginx](https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms)
  - [Crear un SSL (Socket Secure Layer) certificado para Nginx en Ubuntu.18.4](https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04)
  - [Activar o desactivar autoindex en Nginx](https://www.keycdn.com/support/nginx-directory-index)
  - [Videos de c√≥mo montar tu servidor web usando estas tecnologias (MUY √öTIL)](https://www.youtube.com/watch?v=_LQv96MdtCk)


=====================================================================================
# <h1 align="center">TABLA DE PROYECTOS</h1>
=====================================================================================

<br>

| Estimated time | Difficulty | Project | Bonus | Results |
|-----|-------|-------|----------|----------|
|üïê 1 week | Easy |<a href="https://github.com/suker/42-Cadet/tree/master/42-libft">Libft</a>| :white_check_mark: | 114/115 :white_check_mark:|
|üïê 2 week| Easy |<a href="https://github.com/suker/42-Cadet/tree/master/42-get_next_line">Get_next_line</a>| :white_check_mark: | 113/115 ‚úÖ|
|üïê 1 week| Easy |<a href="https://github.com/suker/42-Cadet/tree/master/42-netwhat">Netwhat</a>| ‚ûñ | 100/100 :white_check_mark:|
|üïê 2 ~ 3 weeks| Medium |<a href="https://github.com/suker/42-Cadet/tree/master/42-ft_printf">Ft_printf</a>| ‚úñÔ∏è | 100/115 :white_check_mark:|
|üïê 1 week| Medium |<a href="https://github.com/suker/42-Cadet/tree/master/42-ft_server">Ft_server</a>| ‚ûñ | 100/100 :white_check_mark:|
| ‚è∞ Current Project| Hard |<a href="https://github.com/suker/42-projects/tree/master/C03">Cub3d</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Medium |<a href="#">Exam_Rank_02</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Easy |<a href="#">Libasm</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Medium |<a href="#">Push_swap</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Hard |<a href="#">minishell</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Medium |<a href="#">Ft_services</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Hard |<a href="#">Exam_rank_3</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Easy |<a href="#">Philosopher</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Medium |<a href="#">CPP Module</a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Medium |<a href="#">Exam_Rank_4</a>|‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Medium |<a href="#">Ft_container </a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Hard |<a href="#">Webserv </a>| ‚ùî | 0/100 ‚ùî|
|üïê ‚ùî| Hardest |<a href="#">Ft_transcendence </a>| ‚ùî | 0/100 ‚ùî|


